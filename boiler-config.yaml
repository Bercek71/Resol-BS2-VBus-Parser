
esphome:
  name: resol_vbus
  friendly_name: Resol VBus Boiler

esp32:
  board: esp32dev

wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASS"

logger:
  level: DEBUG
  baud_rate: 0

api:
ota:

# MQTT: raw VBUS payload published to vita/vbus/raw (for Docker bridge / HA).
mqtt:
  id: mqtt_client
  broker: 192.168.1.1  # RPi / HA host – replace with your broker IP or hostname
  # port: 1883
  # username: !secret mqtt_username
  # password: !secret mqtt_password

globals:
  - id: vbus_buf
    type: std::vector<uint8_t>
    restore_value: no

uart:
  id: vbus_uart
  rx_pin: GPIO16
  baud_rate: 9600
  data_bits: 8
  parity: NONE
  stop_bits: 1
  debug:
    direction: RX
    dummy_receiver: true
    after:
      bytes: 1
    sequence:
      - lambda: |-
          for (auto b : bytes) {
            if (b == 0xAA)
              id(vbus_buf).clear();
            id(vbus_buf).push_back(b);
            if (id(vbus_buf).size() > 200)
              id(vbus_buf).erase(id(vbus_buf).begin(), id(vbus_buf).begin() + (id(vbus_buf).size() - 100));
          }

sensor:
  # Resol BS 2 (source 0x4278). Collector = payload[0] - 33.9; Boiler = (payload[36] + 2) / 10 (byte offset 2 → 0x7E→12.8).
  - platform: template
    name: "Collector Temperature"
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      auto &buf = id(vbus_buf);
      if (buf.size() < 50) return NAN;
      size_t s = buf.size() - 50;
      if (buf[s] != 0xAA || buf[s+1] != 0x10 || buf[s+2] != 0x00 || buf[s+3] != 0x78 ||
          buf[s+4] != 0x42 || buf[s+5] != 0x10 || buf[s+6] != 0x00 || buf[s+7] != 0x01 || buf[s+8] != 0x07)
        return NAN;
      return (float)buf[s+9] - 33.9f;

  - platform: template
    name: "Boiler Temperature"
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      auto &buf = id(vbus_buf);
      if (buf.size() < 50) return NAN;
      size_t s = buf.size() - 50;
      if (buf[s] != 0xAA || buf[s+1] != 0x10 || buf[s+2] != 0x00 || buf[s+3] != 0x78 ||
          buf[s+4] != 0x42 || buf[s+5] != 0x10 || buf[s+6] != 0x00 || buf[s+7] != 0x01 || buf[s+8] != 0x07)
        return NAN;
      return ((float)buf[s+45] + 2.0f) / 10.0f;

  - platform: template
    name: "VBus payload size"
    entity_category: diagnostic
    accuracy_decimals: 0
    update_interval: 30s
    lambda: |-
      return (float)id(vbus_buf).size();

# Každých 5 s: při platném VBUS paketu publikovat raw payload (hex) na MQTT vita/vbus/raw
interval:
  - interval: 5s
    then:
      - lambda: |-
          auto &buf = id(vbus_buf);
          if (buf.size() < 50) return;
          size_t s = buf.size() - 50;
          if (buf[s] != 0xAA || buf[s+1] != 0x10 || buf[s+2] != 0x00 || buf[s+3] != 0x78 ||
              buf[s+4] != 0x42 || buf[s+5] != 0x10 || buf[s+6] != 0x00 || buf[s+7] != 0x01 || buf[s+8] != 0x07)
            return;
          std::string hex;
          hex.reserve(82);
          for (int i = 0; i < 41; i++) {
            char b[3];
            sprintf(b, "%02X", buf[s + 9 + i]);
            hex += b;
          }
          id(mqtt_client).publish("vita/vbus/raw", hex);
  - interval: 30s
    then:
      - lambda: |-
          auto &buf = id(vbus_buf);
          size_t last = 0;
          bool found = false;
          if (buf.size() >= 50) {
            size_t prefer = buf.size() - 50;
            if (buf[prefer] == 0xAA && buf[prefer+1] == 0x10 && buf[prefer+2] == 0x00 &&
                buf[prefer+3] == 0x78 && buf[prefer+4] == 0x42 && buf[prefer+5] == 0x10 &&
                buf[prefer+6] == 0x00 && buf[prefer+7] == 0x01 && buf[prefer+8] == 0x07) {
              last = prefer; found = true;
            }
          }
          if (!found) {
            for (size_t pos = buf.size() >= 50 ? buf.size() - 50 : 0; ; pos--) {
              if (pos + 50 <= buf.size() && buf[pos] == 0xAA && buf[pos+1] == 0x10 && buf[pos+2] == 0x00 &&
                  buf[pos+3] == 0x78 && buf[pos+4] == 0x42 && buf[pos+5] == 0x10 &&
                  buf[pos+6] == 0x00 && buf[pos+7] == 0x01 && buf[pos+8] == 0x07) {
                last = pos; found = true; break;
              }
              if (pos == 0) break;
            }
          }
          if (!found || last + 50 > buf.size()) {
            ESP_LOGD("vbus_diag", "Žádný kompletní paket (buffer=%zu)", buf.size());
            return;
          }
          ESP_LOGD("vbus_diag", "Payload (pos 9..24): %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
            buf[last+9], buf[last+10], buf[last+11], buf[last+12], buf[last+13], buf[last+14], buf[last+15], buf[last+16],
            buf[last+17], buf[last+18], buf[last+19], buf[last+20], buf[last+21], buf[last+22], buf[last+23], buf[last+24]);
          ESP_LOGD("vbus_diag", "Payload (pos 25..40): %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
            buf[last+25], buf[last+26], buf[last+27], buf[last+28], buf[last+29], buf[last+30], buf[last+31], buf[last+32],
            buf[last+33], buf[last+34], buf[last+35], buf[last+36], buf[last+37], buf[last+38], buf[last+39], buf[last+40]);
          ESP_LOGD("vbus_diag", "Payload (pos 41..49): %02X %02X %02X %02X %02X %02X %02X %02X %02X",
            buf[last+41], buf[last+42], buf[last+43], buf[last+44], buf[last+45], buf[last+46], buf[last+47], buf[last+48], buf[last+49]);